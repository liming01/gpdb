-- @Description Tests retrieve quit
--
DROP TABLE IF EXISTS t1;
DROP
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
CREATE
insert into t1 select generate_series(1,100);
INSERT 100

--------- Test1: test for quit retrieve will cancel all unfinished QE backend
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: DECLARE c2 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: DECLARE c3 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'parse_endpoint 1 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id1_1 | token_id | host_id | port_id | READY
 endpoint_id1_2 | token_id | host_id | port_id | READY
 endpoint_id1_3 | token_id | host_id | port_id | READY
(3 rows)
1: @out_sh 'parse_endpoint 2 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c2';
 endpoint_id2_1 | token_id | host_id | port_id | READY
 endpoint_id2_2 | token_id | host_id | port_id | READY
 endpoint_id2_3 | token_id | host_id | port_id | READY
(3 rows)
1: @out_sh 'parse_endpoint 3 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c3';
 endpoint_id3_1 | token_id | host_id | port_id | READY
 endpoint_id3_2 | token_id | host_id | port_id | READY
 endpoint_id3_3 | token_id | host_id | port_id | READY
(3 rows)
-- 3&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c3');

-- in one retrieve session, retrieve mutiple tokens (begin retrieving, finished retrieving, not yet retrieve)
0R: @in_sh 'sub_endpoint_name @ENDPOINT1' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT1";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
0R: @in_sh 'sub_endpoint_name @ENDPOINT2' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
 27 
 29 
 34 
 37 
 39 
 41 
 42 
 45 
 51 
 53 
 54 
 55 
 59 
 60 
 65 
 66 
 70 
 75 
 77 
 80 
 81 
 84 
 90 
 92 
 93 
 94 
 97 
 99 
(38 rows)
-- skip TOKEN3 in this session

-- a new retrieve session
3R: @in_sh 'sub_endpoint_name @ENDPOINT1' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT1";
ERROR:  Endpoint endpoint_id1_1 is already attached by receiver(pid: PID) (cdbendpointretrieve.c:LINENO)
DETAIL:  An endpoint can be attached by only one retrieving session for each 'CHECK PARALLEL RETRIEVE CURSOR'
3R: @in_sh 'sub_endpoint_name @ENDPOINT2' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
ERROR:  Endpoint endpoint_id1_1 is already attached by receiver(pid: PID) (cdbendpointretrieve.c:LINENO)
DETAIL:  An endpoint can be attached by only one retrieving session for each 'CHECK PARALLEL RETRIEVE CURSOR'
3R: @in_sh 'sub_endpoint_name @ENDPOINT3' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT3";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)

4: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status 
------------+--------
 c1         | READY  
 c2         | READY  
 c3         | READY  
 c1         | READY  
 c2         | READY  
 c3         | READY  
 c1         | READY  
 c2         | READY  
 c3         | READY  
(9 rows)
-- verify some endpoints is gone
0R: SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
 ?column? | ?column? | status 
----------+----------+--------
 t        | t        | READY  
 f        | t        | FINISH 
 t        | t        | READY  
(3 rows)
-- quit the first retrieve session
0Rq: ... <quitting>
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1<:  <... completed>
ERROR:  canceling MPP operation: "Endpoint retrieve session quit, all unfinished endpoint backends will be cancelled"  (seg0 10.34.58.39:25432 pid=50053)
4: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status   
------------+----------
 c1         | RELEASED 
 c1         | RELEASED 
 c1         | RELEASED 
 c2         | FINISH   
 c2         | READY    
 c2         | READY    
 c3         | READY    
 c3         | READY    
 c3         | READY    
(9 rows)

-- verify some endpoints is gone
3R: SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
 ?column? | ?column? | status 
----------+----------+--------
 f        | t        | FINISH 
 t        | t        | READY  
(2 rows)
-- quit the second retrieve session
3Rq: ... <quitting>
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
3<:  <... completed>
ERROR:  canceling MPP operation: "Endpoint retrieve session quit, all unfinished endpoint backends will be cancelled"  (seg0 10.34.58.39:25432 pid=50073)
4: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status   
------------+----------
 c1         | RELEASED 
 c1         | RELEASED 
 c1         | RELEASED 
 c2         | FINISH   
 c2         | READY    
 c2         | READY    
 c3         | RELEASED 
 c3         | RELEASED 
 c3         | RELEASED 
(9 rows)

*R: @in_sh 'sub @TOKEN2 $TOKEN2' : RETRIEVE all FROM "@TOKEN2";
ERROR:  failed to attach non-existing endpoint of token token_id2 (cdbendpointretrieve.c:214)

ERROR:  Endpoint token_id2 is already attached by receiver(pid: PID) (cdbendpointretrieve.c:LINENO)
DETAIL:  An endpoint can be attached by only one retrieving session for each 'CHECK PARALLEL RETRIEVE CURSOR'

 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)

 a   
-----
 5   
 6   
 9   
 10  
 11  
 13  
 14  
 17  
 21  
 25  
 28  
 32  
 33  
 43  
 52  
 56  
 58  
 62  
 63  
 67  
 73  
 82  
 85  
 96  
 100 
(25 rows)
4: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status   
------------+----------
 c1         | RELEASED 
 c1         | RELEASED 
 c1         | RELEASED 
 c2         | FINISH   
 c2         | FINISH   
 c2         | FINISH   
 c3         | RELEASED 
 c3         | RELEASED 
 c3         | RELEASED 
(9 rows)

1q: ... <quitting>
4: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status   
------------+----------
 c2         | FINISH   
 c2         | FINISH   
 c2         | FINISH   
 c3         | RELEASED 
 c3         | RELEASED 
 c3         | RELEASED 
(6 rows)

2<:  <... completed>
EXECUTE
2: CLOSE c1;
ERROR:  cursor "c1" does not exist
2: END;
END
2q: ... <quitting>
4: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status   
------------+----------
 c3         | RELEASED 
 c3         | RELEASED 
 c3         | RELEASED 
(3 rows)
3q: ... <quitting>
4: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status 
------------+--------
(0 rows)
-- quit all sessions
4q: ... <quitting>
0Rq: ... <quitting>
1Rq: ... <quitting>
2Rq: ... <quitting>
