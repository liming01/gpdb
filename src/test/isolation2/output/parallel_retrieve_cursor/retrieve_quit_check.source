-- @Description Tests retrieve quit
-- Test quitting retrieve sessions interfering with multiple endpoints when calling
-- gp_check_parallel_retrieve_cursor.
DROP TABLE IF EXISTS t1;
DROP
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
CREATE
insert into t1 select generate_series(1,100);
INSERT 100

--------- Test1: test for quit retrieve will cancel all unfinished QE backend
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: DECLARE c2 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: DECLARE c3 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'parse_endpoint 1 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpoint_id1_1 | token_id | host_id | port_id | READY
 endpoint_id1_2 | token_id | host_id | port_id | READY
 endpoint_id1_3 | token_id | host_id | port_id | READY
(3 rows)
1: @out_sh 'parse_endpoint 2 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c2';
 endpoint_id2_1 | token_id | host_id | port_id | READY
 endpoint_id2_2 | token_id | host_id | port_id | READY
 endpoint_id2_3 | token_id | host_id | port_id | READY
(3 rows)
1: @out_sh 'parse_endpoint 3 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c3';
 endpoint_id3_1 | token_id | host_id | port_id | READY
 endpoint_id3_2 | token_id | host_id | port_id | READY
 endpoint_id3_3 | token_id | host_id | port_id | READY
(3 rows)

-- in one retrieve session, retrieve mutiple tokens (begin retrieving, finished retrieving, not yet retrieve)
0R: @in_sh 'sub_endpoint_name @ENDPOINT1' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT1";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
0R: @in_sh 'sub_endpoint_name @ENDPOINT2' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
 27 
 29 
 34 
 37 
 39 
 41 
 42 
 45 
 51 
 53 
 54 
 55 
 59 
 60 
 65 
 66 
 70 
 75 
 77 
 80 
 81 
 84 
 90 
 92 
 93 
 94 
 97 
 99 
(38 rows)
-- skip TOKEN3 in this session

-- a new retrieve session. c1 & c2 cannot be retrieved since an existing retrieve session has
-- retrieved them at least once.
3R: @in_sh 'sub_endpoint_name @ENDPOINT1' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT1";
ERROR:  Endpoint endpoint_id1_1 is already attached by receiver(pid: PID) (cdbendpointretrieve.c:LINENO)
DETAIL:  An endpoint can be attached by only one retrieving session for each 'CHECK PARALLEL RETRIEVE CURSOR'
3R: @in_sh 'sub_endpoint_name @ENDPOINT2' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
ERROR:  Endpoint endpoint_id2_1 is already attached by receiver(pid: PID) (cdbendpointretrieve.c:LINENO)
DETAIL:  An endpoint can be attached by only one retrieving session for each 'CHECK PARALLEL RETRIEVE CURSOR'
3R: @in_sh 'sub_endpoint_name @ENDPOINT3' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT3";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)

2: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status 
------------+--------
 c1         | READY  
 c2         | FINISH 
 c3         | READY  
 c1         | READY  
 c2         | READY  
 c3         | READY  
 c1         | READY  
 c2         | READY  
 c3         | READY  
(9 rows)
-- verify endpoints on seg0 for c2 has been finishied
0R: SELECT cursorname,senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
 cursorname | ?column? | ?column? | status 
------------+----------+----------+--------
 c1         | t        | t        | READY  
 c2         | f        | t        | FINISH 
 c3         | t        | t        | READY  
(3 rows)
-- quit the first retrieve session
0Rq: ... <quitting>

-- Check quiting retrieve session won't impact on finished endpoint.
-- Now the interrupt is checked using WaitLatch() for time: WAIT_NORMAL_TIMEOUT,
-- so here the sleep time should be greater than WAIT_NORMAL_TIMEOUT.
1: SELECT pg_sleep(0.4);
 pg_sleep 
----------
          
(1 row)
-- make sure no error for c2
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c2');
 finished 
----------
 f        
(1 row)
-- The endpoint on seg0 for c1 should be removed since the retrieve session was terminated when
-- the endpoint has not been fully retrieved.
2: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status 
------------+--------
 c2         | FINISH 
 c3         | READY  
 c1         | READY  
 c2         | READY  
 c3         | READY  
 c1         | READY  
 c2         | READY  
 c3         | READY  
(8 rows)

-- verify endpoints for c1 is gone
3R: SELECT cursorname, senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
 cursorname | ?column? | ?column? | status 
------------+----------+----------+--------
 c2         | f        | t        | FINISH 
 c3         | t        | t        | READY  
(2 rows)

-- Now check on c1 will trigger the error, all endpoints should be aborted since the transaction
-- will be terminated.
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c1');
ERROR:  canceling MPP operation: "Endpoint retrieve session quit, all unfinished endpoint backends will be cancelled"  (seg0 127.0.0.1:25432 pid=231244)
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c2');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c3');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
2: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status 
------------+--------
(0 rows)

1: END;
END

2: SELECT cursorname, status FROM gp_endpoints_info(true);
 cursorname | status 
------------+--------
(0 rows)

-- quit all sessions
1q: ... <quitting>
2q: ... <quitting>
3Rq: ... <quitting>
