-- @Description Tests the status for pg_endpoints AND GP_ENDPOINTS_STATUS_INFO()
--
DROP TABLE IF EXISTS t1;
DROP
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
CREATE
insert into t1 select generate_series(1,100);
INSERT 100

--------- Test1: Basic test for parallel retrieve interface & close cursor
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'parse_endpoint 1 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 endpointname         | token                              | hostname    | port  | status
----------------------+------------------------------------+-------------+-------+--------
 endpoint_id1_1 | token_id | host_id | port_id | READY
 endpoint_id1_2 | token_id | host_id | port_id | READY
 endpoint_id1_3 | token_id | host_id | port_id | READY
(3 rows)
1&: CHECK PARALLEL RETRIEVE CURSOR c1;  <waiting ...>

*R: @in_sh 'sub @TOKEN1 ${TOKEN1}': SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 status 
--------
 READY  
(1 row)

 status 
--------
 READY  
(1 row)

 status 
--------
 READY  
(1 row)
*R: @in_sh 'sub @TOKEN1 ${TOKEN1}': RETRIEVE ALL FROM "@TOKEN1";
#-1retrieve> FATAL:  Retrieve auth token is invalid


 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
 27 
 29 
 34 
 37 
 39 
 41 
 42 
 45 
 51 
 53 
 54 
 55 
 59 
 60 
 65 
 66 
 70 
 75 
 77 
 80 
 81 
 84 
 90 
 92 
 93 
 94 
 97 
 99 
(38 rows)

 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)

 a   
-----
 5   
 6   
 9   
 10  
 11  
 13  
 14  
 17  
 21  
 25  
 28  
 32  
 33  
 43  
 52  
 56  
 58  
 62  
 63  
 67  
 73  
 82  
 85  
 96  
 100 
(25 rows)

1<:  <... completed>
EXECUTE
1: CLOSE c1;
CLOSE
-- check no endpoint info
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
 token | status 
-------+--------
(0 rows)
-- check no token info on QE after close PARALLEL RETRIEVE CURSOR
*R: @in_sh 'sub @TOKEN1 ${TOKEN1}': SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

-- error out for closed cursor
1: CHECK PARALLEL RETRIEVE CURSOR c1;
ERROR:  cursor "c1" does not exist
1: ROLLBACK;
ROLLBACK

---------- Test2: enhanced test for parallel retrieve interface status & cursor auto closed when transaction closed
1: BEGIN;
BEGIN
1: DECLARE c2 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_token_cell TOKEN2 3 1 ; match_sub token_id2 $TOKEN2': SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c2';
 token                              | status
------------------------------------+--------
 token_id2 | INIT
 token_id2 | INIT
 token_id2 | INIT
(3 rows)
-- test RETRIEVE report error if PARALLEL RETRIEVE CURSOR not executed
0R: @in_sh 'sub @TOKEN2 ${TOKEN2}': RETRIEVE 10 FROM "@TOKEN2";
ERROR:  the PARALLEL RETRIEVE CURSOR related to endpoint token token_id2 is not EXECUTED. (cdbendpointretrieve.c:LINENO)
1&: CHECK PARALLEL RETRIEVE CURSOR c2;  <waiting ...>

-- check initial status after "CHECK PARALLEL RETRIEVE CURSOR"
2: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
 status 
--------
 READY  
 READY  
 READY  
(3 rows)
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
 t        | f        | READY  
(1 row)

 ?column? | ?column? | status 
----------+----------+--------
 t        | f        | READY  
(1 row)

 ?column? | ?column? | status 
----------+----------+--------
 t        | f        | READY  
(1 row)
-- check status if some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub @TOKEN2 ${TOKEN2}': RETRIEVE 10 FROM "@TOKEN2";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
1R: @in_sh 'sub @TOKEN2 ${TOKEN2}': RETRIEVE ALL FROM "@TOKEN2";
 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)
2: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
 status 
--------
 READY  
 FINISH 
 READY  
(3 rows)
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
 t        | t        | READY  
(1 row)

 ?column? | ?column? | status 
----------+----------+--------
 f        | t        | FINISH 
(1 row)

 ?column? | ?column? | status 
----------+----------+--------
 t        | f        | READY  
(1 row)
-- return 0 row instead of reporting error if finished retrieving data from this endpoint, while other endpoint have not finished retrieving.
1R: @in_sh 'sub @TOKEN2 ${TOKEN2}': RETRIEVE ALL FROM "@TOKEN2";
 a 
---
(0 rows)
-- finished retrieving all endpoints and check status
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': RETRIEVE ALL FROM "@TOKEN2";
#-1retrieve> FATAL:  Retrieve auth token is invalid


 a  
----
 27 
 29 
 34 
 37 
 39 
 41 
 42 
 45 
 51 
 53 
 54 
 55 
 59 
 60 
 65 
 66 
 70 
 75 
 77 
 80 
 81 
 84 
 90 
 92 
 93 
 94 
 97 
 99 
(28 rows)

 a 
---
(0 rows)

 a   
-----
 5   
 6   
 9   
 10  
 11  
 13  
 14  
 17  
 21  
 25  
 28  
 32  
 33  
 43  
 52  
 56  
 58  
 62  
 63  
 67  
 73  
 82  
 85  
 96  
 100 
(25 rows)
2: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
 status 
--------
 FINISH 
 FINISH 
 FINISH 
(3 rows)
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
 f        | t        | FINISH 
(1 row)

 ?column? | ?column? | status 
----------+----------+--------
 f        | t        | FINISH 
(1 row)

 ?column? | ?column? | status 
----------+----------+--------
 f        | t        | FINISH 
(1 row)

1<:  <... completed>
EXECUTE
1: COMMIT;
COMMIT
-- check the cursor auto closed when transaction closed
-- check no endpoint info
1: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
 status 
--------
(0 rows)
-- check no token info on QE after close PARALLEL RETRIEVE CURSOR
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

 token | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid 
-------+------------+-----------+-------------+--------+------+-----------+--------
(0 rows)

-- error out for closed cursor
1: CHECK PARALLEL RETRIEVE CURSOR c2;
ERROR:  cursor "c2" does not exist
1: ROLLBACK;
ROLLBACK

---------- Test3: 2 retrieving sessions connect to the same endpoint report error & cancel QE exec backend
1: BEGIN;
BEGIN
1: DECLARE c3 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_token_cell TOKEN3 3 1 ; match_sub token_id3 $TOKEN3': SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c3';
 token                              | status
------------------------------------+--------
 token_id3 | INIT
 token_id3 | INIT
 token_id3 | INIT
(3 rows)
1&: CHECK PARALLEL RETRIEVE CURSOR c3;  <waiting ...>
0R: @in_sh 'sub @TOKEN3 $TOKEN3': RETRIEVE 10 FROM "@TOKEN3";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
-- a new retrieve session should report error
3R: @in_sh 'sub @TOKEN3 $TOKEN3': RETRIEVE 10 FROM "@TOKEN3";
ERROR:  Endpoint token_id3 is already attached by receiver(pid: PID) (cdbendpointretrieve.c:LINENO)
DETAIL:  An endpoint can be attached by only one retrieving session for each 'CHECK PARALLEL RETRIEVE CURSOR'
-- quit this new retrieve session
3Rq: ... <quitting>
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
1R: @in_sh 'sub @TOKEN3 $TOKEN3': RETRIEVE ALL FROM "@TOKEN3";
 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)
-- get senderpid which is endpoint execution backend
0R: @out_sh 'get_cell PID31 3 1 ; sub "$PID31[ \t]*" senderpid31': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
 senderpid | ?column? | status
-----------+----------+--------
 senderpid31| t        | READY
(1 row)
-- run 'kill -s INT senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s INT ${PID31} && echo "${RAW_STR}" ': SELECT 1;
 ?column? 
----------
 1        
(1 row)
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1<:  <... completed>
ERROR:  canceling MPP operation
-- check no endpoint info left
2: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c3' AND token='@TOKEN3';
 status   
----------
 RELEASED 
 RELEASED 
 RELEASED 
(3 rows)
*R: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: CHECK PARALLEL RETRIEVE CURSOR c3;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
1: ROLLBACK;
ROLLBACK
-- check no endpoint info
2: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c3' AND token='@TOKEN3';
 status 
--------
(0 rows)
*R: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

---------- Test4: terminate (using signal QUIT) QE exec backend
1: BEGIN;
BEGIN
1: DECLARE c4 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_token_cell TOKEN4 3 1 ; match_sub token_id4 $TOKEN4': SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c4';
 token                              | status
------------------------------------+--------
 token_id4 | INIT
 token_id4 | INIT
 token_id4 | INIT
(3 rows)
1&: CHECK PARALLEL RETRIEVE CURSOR c4;  <waiting ...>
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub @TOKEN4 $TOKEN4': RETRIEVE 10 FROM "@TOKEN4";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
1R: @in_sh 'sub @TOKEN4 $TOKEN4': RETRIEVE ALL FROM "@TOKEN4";
 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)
-- get senderpid which is endpoint execution backend
0R: @out_sh 'get_cell PID41 3 1 ; sub "${PID41}[ \t]*" senderpid41': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
 senderpid | ?column? | status
-----------+----------+--------
 senderpid41| t        | READY
(1 row)
-- run 'kill -s QUIT senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s QUIT ${PID41} && echo "${RAW_STR}" ': SELECT 1;
 ?column? 
----------
 1        
(1 row)
-- exit this session because the connection closed, so that it will re-connect next time use this session.
0Rq: ... <quitting>
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1<:  <... completed>
ERROR:  Error on receive from seg0 10.34.50.67:25432 pid=12603: server closed the connection unexpectedly
DETAIL:  
	This probably means the server terminated abnormally
	before or while processing the request.
-- check no endpoint info left
2: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c4' AND token='@TOKEN4';
ERROR:  Error on receive from seg0 10.34.50.67:25432 pid=12724: server closed the connection unexpectedly
DETAIL:  
	This probably means the server terminated abnormally
	before or while processing the request.
*R: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
#-1retrieve> FATAL:  Retrieve auth token is invalid


#0retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: CHECK PARALLEL RETRIEVE CURSOR c4;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
1: ROLLBACK;
ROLLBACK
-- check no endpoint info
2: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c4' AND token='@TOKEN4';
 status 
--------
(0 rows)
*R: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
#-1retrieve> FATAL:  Retrieve auth token is invalid


#0retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

---------- Test5: terminate (using signal TERM) QE exec backend
1: BEGIN;
BEGIN
1: DECLARE c5 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_token_cell TOKEN5 3 1 ; match_sub token_id5 $TOKEN5': SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c5';
 token                              | status
------------------------------------+--------
 token_id5 | INIT
 token_id5 | INIT
 token_id5 | INIT
(3 rows)
1&: CHECK PARALLEL RETRIEVE CURSOR c5;  <waiting ...>
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub @TOKEN5 $TOKEN5': RETRIEVE 10 FROM "@TOKEN5";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
1R: @in_sh 'sub @TOKEN5 $TOKEN5': RETRIEVE ALL FROM "@TOKEN5";
 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)
-- get senderpid which is endpoint execution backend
0R: @out_sh 'get_cell PID51 3 1 ; sub "${PID51}[ \t]*" senderpid51': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
 senderpid | ?column? | status
-----------+----------+--------
 senderpid51| t        | READY
(1 row)
-- run 'kill -s TERM senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s TERM ${PID51} && echo "${RAW_STR}" ': SELECT 1;
 ?column? 
----------
 1        
(1 row)
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1<:  <... completed>
ERROR:  terminating connection due to administrator command  (seg0 10.34.50.67:25432 pid=12905)
-- check no endpoint info left
2: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c5' AND token='@TOKEN5';
 status   
----------
 RELEASED 
 RELEASED 
 RELEASED 
(3 rows)
*R: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: CHECK PARALLEL RETRIEVE CURSOR c5;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
1: ROLLBACK;
ROLLBACK
-- check no endpoint info
2: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c5' AND token='@TOKEN5';
 status 
--------
(0 rows)
*R: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

---------- Test6: Cancel (using signal INT) the process of 'CHECK PARALLEL RETRIEVE CURSOR'
1: BEGIN;
BEGIN
1: DECLARE c6 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_token_cell TOKEN6 3 1 ; match_sub token_id6 $TOKEN6': SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c6';
 token                              | status
------------------------------------+--------
 token_id6 | INIT
 token_id6 | INIT
 token_id6 | INIT
(3 rows)
-- get backend pid of this session which run 'CHECK PARALLEL RETRIEVE CURSOR'
1: @out_sh 'get_cell PID61 3 1 ; sub "${PID61}[ \t]*" QDPid61': select pg_backend_pid();
 pg_backend_pid
----------------
 QDPid61
(1 row)
1&: CHECK PARALLEL RETRIEVE CURSOR c6;  <waiting ...>
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub @TOKEN6 $TOKEN6': RETRIEVE 10 FROM "@TOKEN6";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
1R: @in_sh 'sub @TOKEN6 $TOKEN6': RETRIEVE ALL FROM "@TOKEN6";
 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)
-- run 'kill -s INT QDPid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s INT ${PID61} && echo "${RAW_STR}" ': SELECT 1;
 ?column? 
----------
 1        
(1 row)
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1<:  <... completed>
ERROR:  canceling statement due to user request
-- check no endpoint info left
2: @in_sh 'sub @TOKEN6 $TOKEN6': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c6' AND token='@TOKEN6';
 status   
----------
 RELEASED 
 RELEASED 
 RELEASED 
(3 rows)
*R: @in_sh 'sub @TOKEN6 $TOKEN6': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN6';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: CHECK PARALLEL RETRIEVE CURSOR c6;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
1: ROLLBACK;
ROLLBACK
-- check no endpoint info
2: @in_sh 'sub @TOKEN6 $TOKEN6': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c6' AND token='@TOKEN6';
 status 
--------
(0 rows)
*R: @in_sh 'sub @TOKEN6 $TOKEN6': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN6';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

---------- Test6.1: Cancel (using signal INT) the process of 'CHECK PARALLEL RETRIEVE CURSOR' without rollback
1: BEGIN;
BEGIN
1: DECLARE c61 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_token_cell TOKEN61 3 1 ; match_sub token_id61 $TOKEN61': SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c61';
 token                              | status
------------------------------------+--------
 token_id61 | INIT
 token_id61 | INIT
 token_id61 | INIT
(3 rows)
-- get backend pid of this session which run 'CHECK PARALLEL RETRIEVE CURSOR'
1: @out_sh 'get_cell PID611 3 1 ; sub "${PID611}[ \t]*" QDPid611': select pg_backend_pid();
 pg_backend_pid
----------------
 QDPid611
(1 row)
1&: CHECK PARALLEL RETRIEVE CURSOR c61;  <waiting ...>
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub @TOKEN61 $TOKEN61': RETRIEVE 10 FROM "@TOKEN61";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
1R: @in_sh 'sub @TOKEN61 $TOKEN61': RETRIEVE ALL FROM "@TOKEN61";
 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)
-- run 'kill -s INT QDPid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s INT ${PID611} && echo "${RAW_STR}" ': SELECT 1;
 ?column? 
----------
 1        
(1 row)
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1<:  <... completed>
ERROR:  canceling statement due to user request
-- check no endpoint info left
2: @in_sh 'sub @TOKEN61 $TOKEN61': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c61' AND token='@TOKEN61';
 status   
----------
 RELEASED 
 RELEASED 
 RELEASED 
(3 rows)
*R: @in_sh 'sub @TOKEN61 $TOKEN61': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN61';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)
-- quit the session of 'CHECK PARALLEL RETRIEVE CURSOR' and keep other session connected
1q: ... <quitting>
-- check no endpoint info
2: @in_sh 'sub @TOKEN61 $TOKEN61': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c61' AND token='@TOKEN61';
 status 
--------
(0 rows)
*R: @in_sh 'sub @TOKEN61 $TOKEN61': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN61';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

---------- Test7: terminate (using signal QUIT) the process of 'CHECK PARALLEL RETRIEVE CURSOR'
1: BEGIN;
BEGIN
1: DECLARE c7 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_token_cell TOKEN7 3 1 ; match_sub token_id7 $TOKEN7': SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c7';
 token                              | status
------------------------------------+--------
 token_id7 | INIT
 token_id7 | INIT
 token_id7 | INIT
(3 rows)
-- get backend pid of this session which run 'CHECK PARALLEL RETRIEVE CURSOR'
1: @out_sh 'get_cell PID71 3 1 ; sub "${PID71}[ \t]*" QDPid71': select pg_backend_pid();
 pg_backend_pid
----------------
 QDPid71
(1 row)
1&: CHECK PARALLEL RETRIEVE CURSOR c7;  <waiting ...>
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub @TOKEN7 $TOKEN7': RETRIEVE 10 FROM "@TOKEN7";
 a  
----
 2  
 3  
 4  
 7  
 8  
 16 
 18 
 19 
 22 
 24 
(10 rows)
1R: @in_sh 'sub @TOKEN7 $TOKEN7': RETRIEVE ALL FROM "@TOKEN7";
 a  
----
 1  
 12 
 15 
 20 
 23 
 26 
 30 
 31 
 35 
 36 
 38 
 40 
 44 
 46 
 47 
 48 
 49 
 50 
 57 
 61 
 64 
 68 
 69 
 71 
 72 
 74 
 76 
 78 
 79 
 83 
 86 
 87 
 88 
 89 
 91 
 95 
 98 
(37 rows)
-- run 'kill -s QUIT QDPid' to cancel the endpoint execution backend, retrieve session still can work
-- here need to sleep sometime to wait for endpoint QE backend to detect QD connection lost.
0R: @in_sh 'kill -s QUIT ${PID71}&& sleep 2 && echo "${RAW_STR}" ': SELECT 1;
 ?column? 
----------
 1        
(1 row)
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1<:  <... completed>
server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.
-- quit all sessions on the master, because connect lost
1q: ... <quitting>
2q: ... <quitting>
-1Rq: FAILED:  Sessions not started cannot be quit
-- check no endpoint info left
2: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c7' AND token='@TOKEN7';
 status 
--------
(0 rows)
*R: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: CHECK PARALLEL RETRIEVE CURSOR c7;
ERROR:  cursor "c7" does not exist
1: ROLLBACK;
ROLLBACK
-- check no endpoint info
2: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c7' AND token='@TOKEN7';
 status 
--------
(0 rows)
*R: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';
#-1retrieve> FATAL:  Retrieve auth token is invalid


 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

 ?column? | ?column? | status 
----------+----------+--------
(0 rows)

---------- Test8: Status visibilities for different sessions
1: BEGIN;
BEGIN
1: DECLARE c8 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
1: @out_sh 'get_cell SESSION81 3 2 ; get_token_cell TOKEN81 3 1 ; match_sub_tt session81 $SESSION81 > /dev/null ; match_sub token81 $TOKEN81': SELECT token,sessionid,status FROM GP_ENDPOINTS WHERE cursorname='c8';
 token                              | sessionid | status
------------------------------------+-----------+--------
 token81 | session81| INIT
 token81 | session81| INIT
 token81 | session81| INIT
(3 rows)
-- Session 2 can only see its own cursors by default.
2: BEGIN;
BEGIN
2: DECLARE c8 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
2: @out_sh 'get_cell SESSION82 3 2 ; get_token_cell TOKEN82 3 1 ; match_sub_tt session82 $SESSION82 > /dev/null ; match_sub token82 $TOKEN82': SELECT token,sessionid,status FROM GP_ENDPOINTS WHERE cursorname='c8';
 token                              | sessionid | status
------------------------------------+-----------+--------
 token82 | session82| INIT
 token82 | session82| INIT
 token82 | session82| INIT
(3 rows)
-- Session 2 can only see all cursors with gp_endpoints_info(true).
2: SELECT token,sessionid,status FROM gp_endpoints_info(true) WHERE cursorname='c8';
 token                              | sessionid | status 
------------------------------------+-----------+--------
 token81 | session81| INIT   
 token81 | session81| INIT   
 token81 | session81| INIT   
 token82 | session82| INIT   
 token82 | session82| INIT   
 token82 | session82| INIT   
(6 rows)

1: CLOSE c8;
CLOSE
1: END;
END
2: CLOSE c8;
CLOSE
2: END;
END

