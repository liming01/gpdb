-- @Description Tests the privileges related with endpoints
--
DROP TABLE IF EXISTS t1;
DROP USER IF EXISTS adminuser;
DROP USER IF EXISTS u1;
DROP USER IF EXISTS u2;
CREATE USER adminuser;
ALTER USER adminuser WITH SUPERUSER;
CREATE USER u1;
CREATE USER u2;

SET SESSION AUTHORIZATION u1;
CREATE TABLE t1 (a INT);
RESET SESSION AUTHORIZATION;


--------- Test1: Admin should be able to see other user's endpoint
2: @out_sh 'U1_ID=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo "${RAW_STR}" && export MATCHSUBS="${MATCHSUBS}${NL}m/${U1_ID}/${NL}s/${U1_ID}/u1_id/${NL}"': SELECT usesysid FROM pg_user WHERE usename = 'u1';
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;

--- adminuser should be able to see all the endpoints declared by u1 with status INIT
2: SET SESSION AUTHORIZATION adminuser;
2: SELECT current_user;
2: @out_sh ' TOKEN1=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN1}/${NL}s/${TOKEN1}/token_id1/${NL}" && echo "${RAW_STR}" ': SELECT gp_endpoints.token, pg_user.usename, gp_endpoints.status FROM gp_endpoints, pg_user WHERE gp_endpoints.userid = pg_user.usesysid;

--- execute the cursor by u1
1&: EXECUTE PARALLEL CURSOR c1;

--- adminuser should be able to see the cursor status change to READY
2: SELECT gp_endpoints.token, pg_user.usename, gp_endpoints.status FROM gp_endpoints, pg_user WHERE gp_endpoints.userid = pg_user.usesysid;

--- adminuser should be able to see all endpoints declared by u1 in retrieved mode
*R: SET SESSION AUTHORIZATION adminuser;
*R: SELECT current_user;
*R: SELECT token, userid FROM gp_endpoints_status_info(); 
--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE ALL FROM "@TOKEN1";

1<:
1: CLOSE c1;
1: END;


--------- Test2: Admin should NOT be able to execute other user's parallel cursor
--- FIXME: This test doesn't work for now. When admin execute u1's parallel cursor,
---        the endpoint will belong to admin. Then the u1 won't be able to see the
---        endpoint in retrieve mode.
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;

--- adminuser should NOT be able to execute the parallel cursor
1: SET SESSION AUTHORIZATION adminuser;
1: SELECT current_user;
--- FIXME: ENABLE THIS
--1&: EXECUTE PARALLEL CURSOR c1;
1: CLOSE c1;
1: END;


--------- Test3: Admin should NOT be be able to retrieve from other's parallel cursor
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
1&: EXECUTE PARALLEL CURSOR c1;

2: @out_sh ' TOKEN1=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN1}/${NL}s/${TOKEN1}/token_id1/${NL}" && echo "${RAW_STR}" ': SELECT gp_endpoints.token, pg_user.usename, gp_endpoints.status FROM gp_endpoints, pg_user WHERE gp_endpoints.userid = pg_user.usesysid;

--- adminuser should NOT be able to retrieve from other's parallel cursor
--- FIXME: The error message "ERROR:  failed to attach non-existing endpoint of token
---        tk06467030257775938939 (cdbendpoint.c:1774)" is not user friendly.
*R: SET SESSION AUTHORIZATION adminuser;
*R: SELECT current_user;
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE ALL FROM "@TOKEN1";

--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE ALL FROM "@TOKEN1";

1<:
1: CLOSE c1;
1: END;


--------- Test4: Admin should be be able to close parallel cursor
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
--- Close c1 by adminuser
1: SET SESSION AUTHORIZATION adminuser;
1: CLOSE c1;
1: END;


--------- Test5: u2 should NOT be able to see or retrieve from u1's endpoints
--- c1 is declared and executed by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh ' TOKEN1=` echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN1}/${NL}s/${TOKEN1}/token_id1/${NL}" && echo "${RAW_STR}" ': SELECT gp_endpoints.token, pg_user.usename, gp_endpoints.status FROM gp_endpoints, pg_user WHERE gp_endpoints.userid = pg_user.usesysid;

--- u2 is not able to see u1's endpoints on master
1: SET SESSION AUTHORIZATION u2;
1: SELECT * from gp_endpoints;

--- execute the cursor by u1
1: SET SESSION AUTHORIZATION u1;
1&: EXECUTE PARALLEL CURSOR c1;

--- u2 is not able to see u1's endpoints in RETRIEVE mode
*R: SET SESSION AUTHORIZATION u2;
*R: SELECT * FROM gp_endpoints_status_info();

--- u2 is not able to retrieve from u1's endpoints in RETRIEVE mode
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE ALL FROM "@TOKEN1";

--- Switch back to u1 and retrieve all to finish the test
*R: SET SESSION AUTHORIZATION u1;
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE ALL FROM "@TOKEN1";

1<:
1: CLOSE c1;
1: END;


--------- Test6: u2 should NOT be able to execute other u1's parallel cursor if it cannot access t1
--- FIXME: This test doesn't work for now. Similar as the admin case.
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;

--- u2 cannot execute u1's cursor if it cannot access t1
1: SET SESSION AUTHORIZATION u2;
1: EXECUTE PARALLEL CURSOR c1;

1: END;

--------- Test7: u2 should NOT be able to execute other u1's parallel cursor even when it can access t1
--- FIXME: This test doesn't work for now. Similar as the admin case.
--- c1 is declared by u1
1: SET SESSION AUTHORIZATION u1;
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;

---1: EXECUTE PARALLEL CURSOR c1;
1: SET SESSION AUTHORIZATION adminuser;
1: GRANT ALL ON TABLE t1 TO u2;
1: SET SESSION AUTHORIZATION u2;
--- FIXME: Enable below
-- 1: EXECUTE PARALLEL CURSOR c1;

1: END;
