-- @Description Tests with faut inject
--
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
insert into t1 select generate_series(1,100);

DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT) DISTRIBUTED by (a);
insert into t2 select generate_series(1,10000000);

CREATE EXTENSION IF NOT EXISTS gp_inject_fault;

--------- Test1: fault injection end-point shared memory slot full on QE
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'reset', 2);
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'full_memory_slot', 2);

1: BEGIN;
-- should report error on seg0
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
1: ROLLBACK;
-- test same error on another session
3: BEGIN;
3: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
3: ROLLBACK;
-- reset the fault injection
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'reset', 2);
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'revert_memory_slot', 2);
--should work as normal
1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh 'get_token_cell TOKEN1 3 1 ; match_sub token_id1 $TOKEN1' : SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1&: EXECUTE PARALLEL CURSOR c1;

*R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1' or token='tk0000000000';
*R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:
1: CLOSE c1;
-- check no endpoint info
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1' or cursorname = 'FAULT_INJECTION_CURSOR';
-- check no token info on QE after close parallel cursor
*R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1' or token='tk0000000000';

1: ROLLBACK;

--------- Test2: fault injection end-point shared memory slot full on QD
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'reset', 1);
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'full_memory_slot', 1);

1: BEGIN;
-- should report error on QD
1: DECLARE c2 PARALLEL CURSOR FOR SELECT * FROM t1;
1: ROLLBACK;
-- test same error on another session
3: BEGIN;
3: DECLARE c2 PARALLEL CURSOR FOR SELECT * FROM t1;
3: ROLLBACK;
-- reset the fault injection
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'reset', 1);
2: SELECT gp_inject_fault('endpoint_shared_memory_slot_full', 'revert_memory_slot', 1);
--should work as normal
1: BEGIN;
1: DECLARE c2 PARALLEL CURSOR FOR SELECT * FROM t1;
1: @out_sh 'get_token_cell TOKEN2 3 1 ; match_sub token_id2 $TOKEN2' : SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c2';
1&: EXECUTE PARALLEL CURSOR c2;

*R: @in_sh 'sub @TOKEN2 $TOKEN2' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2' or token='tk0000000000';
*R: @in_sh 'sub @TOKEN2 $TOKEN2' : RETRIEVE ALL FROM "@TOKEN2";

1<:
1: CLOSE c2;
-- check no endpoint info
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c2' or cursorname = 'FAULT_INJECTION_CURSOR';
-- check no token info on QE after close parallel cursor
*R: @in_sh 'sub @TOKEN2 $TOKEN2' : SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2' or token='tk0000000000';

1: ROLLBACK;

--- Test3: fault inject while retrieving tuples from endpoint
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'interrupt', 2);

1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * from t1;
1: @out_sh 'get_token_cell TOKEN1 3 1 ; match_sub token_id1 $TOKEN1' : SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1&: EXECUTE PARALLEL CURSOR c1;

0R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
0R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:

1R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
1R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

2R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
2R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:
1: ROLLBACK;
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);

-- Test4: fault inject at the 5th time while retrieving tuples from endpoint
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'interrupt', '', '', '', 5, 5, 0, 3::smallint);

1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * from t1;
1: @out_sh 'get_token_cell TOKEN1 3 1 ; match_sub token_id1 $TOKEN1' : SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1&: EXECUTE PARALLEL CURSOR c1;

1R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
1R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:

0R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
0R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

2R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
2R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:
1: ROLLBACK;
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);

-- Test5: error inject at the 5th time while retrieving tuples from endpoint
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'error', '', '', '', 5, 5, 0, 2::smallint);

1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * from t1;
1: @out_sh 'get_token_cell TOKEN1 3 1 ; match_sub token_id1 $TOKEN1' : SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1&: EXECUTE PARALLEL CURSOR c1;

1R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
1R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

0R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
0R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:

2R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
2R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:
1: ROLLBACK;
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);

-- Test6: error inject at the 5th time while retrieving tuples from endpoint. other retrieve session still retrieving.
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 4);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'sleep', '', '', '', 1, 6, 10, 2::smallint);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'sleep', '', '', '', 1, 6, 10, 4::smallint);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'interrupt', '', '', '', 5, 5, 0, 3::smallint);

1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * from t1;
1: @out_sh 'get_token_cell TOKEN1 3 1 ; match_sub token_id1 $TOKEN1' : SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1&: EXECUTE PARALLEL CURSOR c1;

0R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
0R&: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

2R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
2R&: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
1R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:

0R<:
2R<:

1<:
1: ROLLBACK;
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 2);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 4);


-- Test7: error inject at the 5th time while retrieving tuples from endpoint. other retrieve session finished.
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'interrupt', '', '', '', 1000, 1000, 0, 3::smallint);

1: BEGIN;
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * from t2;
1: @out_sh 'get_token_cell TOKEN1 3 1 ; match_sub token_id1 $TOKEN1' : SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1&: EXECUTE PARALLEL CURSOR c1;

0R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
0R&: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

2R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
2R&: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1R: @in_sh 'sub @TOKEN1 $TOKEN1' : SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
1R: @in_sh 'sub @TOKEN1 $TOKEN1' : RETRIEVE ALL FROM "@TOKEN1";

1<:

0R<:
2R<:

1<:
1: ROLLBACK;
1: SELECT gp_inject_fault('fetch_tuples_from_endpoint', 'reset', 3);
