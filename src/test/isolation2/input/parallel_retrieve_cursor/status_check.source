-- @Description Tests the status for pg_endpoints AND GP_ENDPOINTS_STATUS_INFO(), focus in nowait mode
-- need to fault injection to gp_check_parallel_retrieve_cursor() 
-- 
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
insert into t1 select generate_series(1,100);

CREATE EXTENSION IF NOT EXISTS gp_inject_fault;

--------- Test1: Basic test for parallel retrieve interface & close cursor
1: BEGIN;
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 1 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c1');

*R: @in_sh 'sub_endpoint_name @ENDPOINT1': SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE endpointname='@ENDPOINT1';
*R: @in_sh 'sub_endpoint_name @ENDPOINT1': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT1";

1: SELECT * FROM gp_check_parallel_retrieve_cursor('c1');
1: CLOSE c1;
-- check no endpoint info
1: SELECT token,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
-- check no token info on QE after close PARALLEL RETRIEVE CURSOR
*R: @in_sh 'sub @TOKEN1 ${TOKEN1}': SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';

-- error out for closed cursor
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c1');
1: ROLLBACK;

---------- Test2: enhanced test for parallel retrieve interface status & cursor auto closed when transaction closed
1: BEGIN;
1: DECLARE c2 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 2 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c2';
-- test RETRIEVE success on seg1
0R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT2";
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c2');

-- check initial status after "CHECK PARALLEL RETRIEVE CURSOR"
2: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
-- check status if some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT2";
1R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
2: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
-- return 0 row instead of reporting error if finished retrieving data from this endpoint, while other endpoint have not finished retrieving.
1R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
-- finished retrieving all endpoints and check status
*R: @in_sh 'sub_endpoint_name @ENDPOINT2': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
2: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';

1: SELECT * FROM gp_check_parallel_retrieve_cursor('c2');
1: COMMIT;
-- check the cursor auto closed when transaction closed
-- check no endpoint info
1: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c2' AND token='@TOKEN2';
-- check no token info on QE after close PARALLEL RETRIEVE CURSOR
*R: @in_sh 'sub @TOKEN2 ${TOKEN2}': SELECT * FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';

-- error out for closed cursor
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c2');
1: ROLLBACK;

---------- Test3: 2 retrieving sessions connect to the same endpoint report error & cancel QE exec backend
1: BEGIN;
1: DECLARE c3 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 3 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c3';
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c3');
0R: @in_sh 'sub_endpoint_name @ENDPOINT3': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT3";
-- a new retrieve session should report error
3R: @in_sh 'sub_endpoint_name @ENDPOINT3': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT3";
-- quit this new retrieve session
3Rq:
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
1R: @in_sh 'sub_endpoint_name @ENDPOINT3': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT3";
-- get senderpid which is endpoint execution backend
0R: @out_sh 'get_cell PID31 3 1 ; sub "$PID31[ \t]*" senderpid31': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- run 'kill -s INT senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s INT ${PID31} && echo "${RAW_STR}" ': SELECT 1;
-- check it can cancel the "gp_wait_parallel_retrieve_cursor"
1: SELECT pg_sleep(0.4);
2: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c3' AND token='@TOKEN3';
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c3');
-- check no endpoint info left
2: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c3' AND token='@TOKEN3';
*R: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c3');
1: ROLLBACK;
-- check no endpoint info 
2: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c3' AND token='@TOKEN3';
*R: @in_sh 'sub @TOKEN3 $TOKEN3': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';

---------- Test4: terminate (using signal QUIT) QE exec backend
1: BEGIN;
1: DECLARE c4 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 4 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c4';
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c4');
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub_endpoint_name @ENDPOINT4': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT4";
1R: @in_sh 'sub_endpoint_name @ENDPOINT4': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT4";
-- get senderpid which is endpoint execution backend
0R: @out_sh 'get_cell PID41 3 1 ; sub "${PID41}[ \t]*" senderpid41': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- run 'kill -s QUIT senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s QUIT ${PID41} && echo "${RAW_STR}" ': SELECT 1;
-- exit this session because the connection closed, so that it will re-connect next time use this session.
0Rq:
-- check it can cancel the "gp_wait_parallel_retrieve_cursor"
1: SELECT pg_sleep(0.4);
2: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c4' AND token='@TOKEN4';
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c4');
-- check no endpoint info left
2q:
2: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c4' AND token='@TOKEN4';
*R: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c4');
1: ROLLBACK;
-- check no endpoint info 
2: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c4' AND token='@TOKEN4';
*R: @in_sh 'sub @TOKEN4 $TOKEN4': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
2Rq:

---------- Test5: terminate (using signal TERM) QE exec backend
1: BEGIN;
1: DECLARE c5 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 5 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c5';
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c5');
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub_endpoint_name @ENDPOINT5': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT5";
-- 1R still bind to Test4 session, so can not retrieve from current endpoint.
1R: @in_sh 'sub_endpoint_name @ENDPOINT5': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT5";
-- Since seg1 retrieve session is bind to Test4 session. And Test4 session get killed. We need to restart it.
1Rq:
1R: @in_sh 'sub_endpoint_name @ENDPOINT5': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT5";
-- get senderpid which is endpoint execution backend
0R: @out_sh 'get_cell PID51 3 1 ; sub "${PID51}[ \t]*" senderpid51': SELECT senderpid, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- run 'kill -s TERM senderpid' to cancel the endpoint execution backend, retrieve session still can work
0R: @in_sh 'kill -s TERM ${PID51} && echo "${RAW_STR}" ': SELECT 1;
-- check it can cancel the "gp_wait_parallel_retrieve_cursor"
1: SELECT pg_sleep(0.4);
2: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c5' AND token='@TOKEN5';
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c5');
-- check no endpoint info left
2: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c5' AND token='@TOKEN5';
*R: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c5');
1: ROLLBACK;
-- check no endpoint info 
2: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c5' AND token='@TOKEN5';
*R: @in_sh 'sub @TOKEN5 $TOKEN5': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN5';

---------- Test6: Cancel (using signal INT) the process of 'CHECK PARALLEL RETRIEVE CURSOR'
-- faul injection on QD
1: SELECT gp_inject_fault('check_parallel_retrieve_cursor_after_udf', 'reset', 1); 
1: SELECT gp_inject_fault('check_parallel_retrieve_cursor_after_udf', 'interrupt', 1);
1: BEGIN;
1: DECLARE c6 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 6 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c6';
-- get backend pid of this session which run 'gp_wait_parallel_retrieve_cursor'
1: @out_sh 'get_cell PID61 3 1 ; sub "${PID61}[ \t]*" QDPid61': select pg_backend_pid();
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub_endpoint_name @ENDPOINT6': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT6";
1R: @in_sh 'sub_endpoint_name @ENDPOINT6': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT6";
-- fault injection interrupt to cancel the endpoint execution backend, retrieve session still can work
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c6');
-- check no endpoint info left
2: @in_sh 'sub @TOKEN6 $TOKEN6': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c6' AND token='@TOKEN6';
*R: @in_sh 'sub @TOKEN6 $TOKEN6': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN6';
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c6');
1: ROLLBACK;
-- check no endpoint info
2: @in_sh 'sub @TOKEN6 $TOKEN6': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c6' AND token='@TOKEN6';
*R: @in_sh 'sub @TOKEN6 $TOKEN6': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN6';

---------- Test6.1: Cancel (using signal INT) the process of 'CHECK PARALLEL RETRIEVE CURSOR' without rollback
-- faul injection on QD
1: SELECT gp_inject_fault('check_parallel_retrieve_cursor_after_udf', 'reset', 1); 
1: SELECT gp_inject_fault('check_parallel_retrieve_cursor_after_udf', 'interrupt', 1);
1: BEGIN;
1: DECLARE c61 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 61 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c61';
-- get backend pid of this session which run 'gp_wait_parallel_retrieve_cursor'
1: @out_sh 'get_cell PID611 3 1 ; sub "${PID611}[ \t]*" QDPid611': select pg_backend_pid();
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub_endpoint_name @ENDPOINT61': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT61";
1R: @in_sh 'sub_endpoint_name @ENDPOINT61': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT61";
-- fault injection interrupt to cancel the endpoint execution backend, retrieve session still can work
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c61');
-- check no endpoint info left
2: @in_sh 'sub @TOKEN61 $TOKEN61': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c61' AND token='@TOKEN61';
*R: @in_sh 'sub @TOKEN61 $TOKEN61': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN61';
-- quit the session of 'CHECK PARALLEL RETRIEVE CURSOR' and keep other session connected
1q:
-- check no endpoint info
2: @in_sh 'sub @TOKEN61 $TOKEN61': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c61' AND token='@TOKEN61';
*R: @in_sh 'sub @TOKEN61 $TOKEN61': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN61';
0Rq:
1Rq:
2Rq:

---------- Test7: terminate (using signal QUIT) the process of 'CHECK PARALLEL RETRIEVE CURSOR'
1: SELECT gp_inject_fault('check_parallel_retrieve_cursor_after_udf', 'reset', 1); 
1: SELECT gp_inject_fault('check_parallel_retrieve_cursor_after_udf', 'sleep', '', '', '', 1, 1, 1, 2::smallint);
1: BEGIN;
1: DECLARE c7 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 7 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c7';
-- get backend pid of this session which run 'gp_wait_parallel_retrieve_cursor'
1: @out_sh 'get_cell PID71 3 1 ; sub "${PID71}[ \t]*" QDPid71': select pg_backend_pid();
-- some endpoint retrieve partial results, some endpoint finished retrieving, some endpoint not start retrieving
0R: @in_sh 'sub_endpoint_name @ENDPOINT7': RETRIEVE 10 FROM ENDPOINT "@ENDPOINT7";
1R: @in_sh 'sub_endpoint_name @ENDPOINT7': RETRIEVE ALL FROM ENDPOINT "@ENDPOINT7";
2R: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';
-- run 'kill -s QUIT QDPid' to cancel the endpoint execution backend, retrieve session still can work
-- here need to sleep sometime to wait for endpoint QE backend to detect QD connection lost.
1&: SELECT * FROM gp_check_parallel_retrieve_cursor('c7');
0R: @in_sh 'kill -s QUIT ${PID71}&& sleep 2 && echo "${RAW_STR}" ': SELECT 1;
-- check it can cancel the "gp_wait_parallel_retrieve_cursor"
1<:
-- quit all sessions on the master, because connect lost
1q:
2q:
-1Rq:
-- check no endpoint info left
2: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c7' AND token='@TOKEN7';
*R: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';
-- report error for EXECUTE canceled PARALLEL RETRIEVE CURSOR
1: SELECT * FROM gp_wait_parallel_retrieve_cursor('c7');
1: ROLLBACK;
-- check no endpoint info
2: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT status FROM gp_endpoints_info(true) WHERE cursorname='c7' AND token='@TOKEN7';
*R: @in_sh 'sub @TOKEN7 $TOKEN7': SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN7';

---------- Test8: Status visibilities for different sessions
1: BEGIN;
1: DECLARE c8 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'get_cell SESSION81 3 2 ; get_token_cell TOKEN81 3 1 ; match_sub_tt session81 $SESSION81 > /dev/null ; match_sub token81 $TOKEN81': SELECT token,sessionid,status FROM GP_ENDPOINTS WHERE cursorname='c8';
-- Session 2 can only see its own cursors by default.
2: BEGIN;
2: DECLARE c8 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
2: @out_sh 'get_cell SESSION82 3 2 ; get_token_cell TOKEN82 3 1 ; match_sub_tt session82 $SESSION82 > /dev/null ; match_sub token82 $TOKEN82': SELECT token,sessionid,status FROM GP_ENDPOINTS WHERE cursorname='c8';
-- Session 2 can only see all cursors with gp_endpoints_info(true).
2: SELECT token,sessionid,status FROM gp_endpoints_info(true) WHERE cursorname='c8';

1: CLOSE c8;
1: END;
2: CLOSE c8;
2: END;

