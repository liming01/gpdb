-- @Description Tests retrieve quit
-- Test quitting retrieve sessions interfering with multiple endpoints when calling
-- gp_wait_parallel_retrieve_cursor.
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
insert into t1 select generate_series(1,100);

--------- Test1: test for wait for a finished endpoint
1: BEGIN;
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: DECLARE c2 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: DECLARE c3 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 1 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1: @out_sh 'parse_endpoint 2 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c2';
1: @out_sh 'parse_endpoint 3 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c3';

-- Wait until the c2 has been fully retrieved
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c2');

2: SELECT cursorname, status FROM gp_endpoints_info(true);

-- in all retrieve sessions, retrieve mutiple tokens (begin retrieving, finished retrieving, not yet retrieve)
*R: @in_sh 'sub_endpoint_name @ENDPOINT1' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT1";
*R: @in_sh 'sub_endpoint_name @ENDPOINT2' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
-- skip TOKEN3 in this session

-- Retrieving on C2 finished.
1<:

0R: SELECT cursorname,senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- quit the retrieve session
0Rq:

2: SELECT cursorname, status FROM gp_endpoints_info(true);

-- Since c1 has been only partially retrieved, an error will be raised when transaction ends.
1: END;

2: SELECT cursorname, status FROM gp_endpoints_info(true);

--------- Test2: test for wait for quit partially retrieving session will abort all endpoints in the transaction.

1: BEGIN;
1: DECLARE c4 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: DECLARE c5 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: DECLARE c6 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 4 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c4';
1: @out_sh 'parse_endpoint 5 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c5';
1: @out_sh 'parse_endpoint 6 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c6';

-- Wait until retrieving session for c4 quits
1&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c4');

-- in one retrieve session, retrieve multiple tokens (begin retrieving, finished retrieving, not yet retrieve)
*R: @in_sh 'sub_endpoint_name @ENDPOINT4' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT4";
*R: @in_sh 'sub_endpoint_name @ENDPOINT5' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT5";
-- skip TOKEN3 in this session

0R: SELECT cursorname,senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
0Rq:

-- Since retrieving session abort, waiting should be interrupted.
1<:

-- All endpoints should be removed since error happened.
2: SELECT cursorname, status FROM gp_endpoints_info(true);

-- quit all sessions
1q:
2q:
