-- @Description Tests retrieve quit
-- 
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT) DISTRIBUTED by (a);
insert into t1 select generate_series(1,100);

--------- Test1: test for quit retrieve will cancel all unfinished QE backend
1: BEGIN;
1: DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: DECLARE c2 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: DECLARE c3 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
1: @out_sh 'parse_endpoint 1 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c1';
1: @out_sh 'parse_endpoint 2 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c2';
1: @out_sh 'parse_endpoint 3 1 2 3 4' : SELECT endpointname,token,hostname,port,status FROM gp_endpoints_info(true) WHERE cursorname='c3';
-- 3&: SELECT * FROM gp_wait_parallel_retrieve_cursor('c3');

-- in one retrieve session, retrieve mutiple tokens (begin retrieving, finished retrieving, not yet retrieve)
0R: @in_sh 'sub_endpoint_name @ENDPOINT1' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT1";
0R: @in_sh 'sub_endpoint_name @ENDPOINT2' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
-- skip TOKEN3 in this session

-- a new retrieve session
3R: @in_sh 'sub_endpoint_name @ENDPOINT1' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT1";
3R: @in_sh 'sub_endpoint_name @ENDPOINT2' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
3R: @in_sh 'sub_endpoint_name @ENDPOINT3' : RETRIEVE 10 FROM ENDPOINT "@ENDPOINT3";

4: SELECT cursorname, status FROM gp_endpoints_info(true);
-- verify some endpoints is gone
0R: SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- quit the first retrieve session
0Rq:
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c1');
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c2');
4: SELECT cursorname, status FROM gp_endpoints_info(true);

-- verify some endpoints is gone
3R: SELECT senderpid<>-1, receiverpid<>-1, status FROM GP_ENDPOINTS_STATUS_INFO();
-- quit the second retrieve session
3Rq:
-- check it can cancel the "CHECK PARALLEL RETRIEVE CURSOR"
1: SELECT * FROM gp_check_parallel_retrieve_cursor('c3');
4: SELECT cursorname, status FROM gp_endpoints_info(true);

*R: @in_sh 'sub_endpoint_name @ENDPOINT2' : RETRIEVE ALL FROM ENDPOINT "@ENDPOINT2";
4: SELECT cursorname, status FROM gp_endpoints_info(true);

1: CLOSE c2;
4: SELECT cursorname, status FROM gp_endpoints_info(true);

1: END;
4: SELECT cursorname, status FROM gp_endpoints_info(true);

1q:
4: SELECT cursorname, status FROM gp_endpoints_info(true);

-- quit all sessions
4q:
0Rq:
1Rq:
2Rq:
